---
description: Auto-generate reusable .mdc templates **TRIGGERS:** "build system", "create automation", "workflow", "template", "successful implementation", "reuse pattern"
globs: ["automation-systems/**/src/**", "**/requirements.txt", "**/package.json", "**/README*.md", "**/quick_start.py"]
alwaysApply: false
---

# ðŸ”„ Auto-Template Generation & System Learning

**PURPOSE:** Automatically capture, analyze, and templatize successful automation systems for reuse and continuous improvement.

**TRIGGERS:** When building automation systems, processing workflows, or creating development projects - automatically analyze patterns and generate reusable templates.

## ðŸŽ¯ Core Template Generation Principles

### **1. Automatic System Capture**
- Every successful automation system gets analyzed and templatized
- Pattern extraction from working implementations
- Reusable .mdc templates generated automatically
- Integration with meta-learning system

### **2. Template Evolution**
- Templates improve with each implementation
- Success patterns get reinforced
- Failed patterns get eliminated
- Continuous optimization through usage data

## ðŸ”„ Auto-Template Generation Process

### **STEP 1: System Analysis & Extraction**
```python
def analyze_and_template_system(automation_system):
    """
    Automatically analyze a successful automation system and generate reusable template
    """
    analysis = {
        "system_type": detect_system_type(automation_system),
        "core_patterns": extract_code_patterns(automation_system),
        "architecture": analyze_architecture(automation_system),
        "dependencies": extract_dependencies(automation_system),
        "enhancements": identify_applied_enhancements(automation_system),
        "user_interaction": analyze_user_flow(automation_system),
        "performance_metrics": measure_performance(automation_system)
    }
    
    return generate_mdc_template(analysis)
```

### **STEP 2: Template Structure Generation**
```mdc
# Auto-Generated Template: {system_type}
# Generated: {timestamp}
# Success Rate: {success_rate}
# Performance: {performance_metrics}

## Core Architecture Pattern
{architecture_description}

## Code Templates
{code_templates}

## Enhancement Patterns
{enhancement_patterns}

## Dependencies & Setup
{dependency_templates}

## User Experience Flow
{ux_flow_templates}
```

### **STEP 3: Integration with Main System**
```python
TEMPLATE_REGISTRY = {
    "interview_analysis": {
        "template_path": "templates/automation-systems/interview-analysis.mdc",
        "last_updated": "{timestamp}",
        "success_implementations": 1,
        "average_performance": "{metrics}",
        "user_satisfaction": "{rating}"
    }
}
```

## ðŸ“š Template Library Structure

### **Template Organization**
```
.cursor/rules/templates/
â”œâ”€â”€ automation-systems/           # System-specific templates
â”‚   â”œâ”€â”€ interview-analysis.mdc    # Interview analysis automation
â”‚   â”œâ”€â”€ data-processing.mdc       # Data processing automation
â”‚   â”œâ”€â”€ web-scraping.mdc         # Web automation
â”‚   â””â”€â”€ api-integration.mdc       # API integration automation
â”œâ”€â”€ patterns/                     # Reusable patterns
â”‚   â”œâ”€â”€ file-processors.mdc      # File processing patterns
â”‚   â”œâ”€â”€ report-generators.mdc    # Report generation patterns
â”‚   â”œâ”€â”€ error-handlers.mdc       # Error handling patterns
â”‚   â””â”€â”€ progress-trackers.mdc    # Progress tracking patterns
â””â”€â”€ enhancements/                 # Enhancement templates
    â”œâ”€â”€ validation-layers.mdc     # Validation enhancement patterns
    â”œâ”€â”€ performance-opts.mdc      # Performance optimization patterns
    â””â”€â”€ user-experience.mdc       # UX enhancement patterns
```

### **Template Content Structure**
```mdc
# {Template Name} - Auto-Generated Template

## Metadata
- **Generated**: {timestamp}
- **System Type**: {type}
- **Success Implementations**: {count}
- **Average Build Time**: {time}
- **User Rating**: {rating}/5

## Architecture Overview
{high_level_description}

## Core Implementation Pattern
```python
{core_code_template}
```

## Enhancement Integration Points
{enhancement_hooks}

## Dependencies Template
```txt
{dependency_list}
```

## Configuration Template
```json
{config_template}
```

## Documentation Template
{documentation_structure}

## Success Metrics
- Build Time: {time}
- Code Quality: {quality_score}
- User Experience: {ux_score}
- Reusability: {reuse_score}

## Optimization Opportunities
{improvement_suggestions}
```

## ðŸš€ Automatic Generation Triggers

### **Post-Build Template Generation**
```python
def post_build_template_generation(built_system):
    """Automatically triggered after successful system build"""
    
    # 1. Analyze built system
    system_analysis = analyze_automation_system(built_system)
    
    # 2. Extract reusable patterns
    patterns = extract_patterns(system_analysis)
    
    # 3. Generate .mdc template
    template = generate_template(patterns)
    
    # 4. Save to template library
    save_template(template, f"templates/automation-systems/{system_analysis.type}.mdc")
    
    # 5. Update template registry
    update_template_registry(system_analysis)
    
    # 6. Integrate with meta-learning
    update_meta_learning_patterns(patterns)
```

### **Template Update Mechanism**
```python
def update_existing_template(system_type, new_implementation):
    """Update template based on new successful implementation"""
    
    existing_template = load_template(system_type)
    new_patterns = extract_patterns(new_implementation)
    
    # Merge patterns and improve template
    improved_template = merge_and_improve(existing_template, new_patterns)
    
    # Update success metrics
    improved_template.metadata.implementations += 1
    improved_template.metadata.last_updated = now()
    
    # Save improved template
    save_template(improved_template)
```

## ðŸ§  Integration with Meta-Learning System

### **Pattern Recognition Enhancement**
```python
META_LEARNING_INTEGRATION = {
    "pattern_extraction": "auto_extract_successful_patterns",
    "failure_analysis": "analyze_failed_implementations",
    "optimization_suggestions": "generate_improvement_recommendations",
    "template_evolution": "evolve_templates_based_on_usage"
}
```

### **System Prompt Integration**
```python
def integrate_with_system_prompt():
    """
    Automatically update system prompt with learned patterns
    """
    # 1. Extract successful patterns from templates
    successful_patterns = extract_all_successful_patterns()
    
    # 2. Analyze system prompt effectiveness  
    prompt_analysis = analyze_system_prompt_performance()
    
    # 3. Generate prompt improvements
    prompt_improvements = generate_prompt_optimizations(
        successful_patterns, 
        prompt_analysis
    )
    
    # 4. Update system prompt template
    update_system_prompt_template(prompt_improvements)
```

## ðŸŽ¯ Template Usage Integration

### **Template-Driven System Building**
```python
def build_from_template(system_type, user_requirements):
    """Use templates to accelerate system building"""
    
    # 1. Load relevant template
    template = load_template(system_type)
    
    # 2. Customize for user requirements
    customized_system = customize_template(template, user_requirements)
    
    # 3. Apply proven enhancement patterns
    enhanced_system = apply_enhancement_patterns(customized_system)
    
    # 4. Build system using template guidance
    built_system = build_system(enhanced_system)
    
    # 5. Update template based on results
    update_template_with_results(template, built_system)
    
    return built_system
```

### **Dynamic Template Selection**
```python
TEMPLATE_SELECTION_LOGIC = {
    "keyword_matching": "match_user_requirements_to_templates",
    "success_rate_weighting": "prefer_templates_with_higher_success",
    "performance_optimization": "choose_fastest_building_templates",
    "user_experience": "select_templates_with_best_ux_ratings"
}
```

## ðŸ“Š Template Analytics & Optimization

### **Template Performance Metrics**
```python
TEMPLATE_METRICS = {
    "usage_frequency": "how_often_template_used",
    "success_rate": "percentage_successful_builds",
    "build_time": "average_time_to_complete",
    "user_satisfaction": "user_ratings_feedback",
    "code_quality": "automated_quality_analysis",
    "maintainability": "ease_of_modification_score"
}
```

### **Continuous Template Improvement**
```python
def optimize_templates_continuously():
    """Continuously improve templates based on usage data"""
    
    for template in get_all_templates():
        # Analyze template performance
        performance = analyze_template_performance(template)
        
        # Identify improvement opportunities
        improvements = identify_improvements(performance)
        
        # Apply optimizations
        if improvements.confidence > OPTIMIZATION_THRESHOLD:
            apply_template_optimizations(template, improvements)
            
        # A/B test improvements
        schedule_ab_test(template, improvements)
```

## ðŸ”„ Auto-Update Workflow

### **Complete Auto-Update Cycle**
```python
def complete_auto_update_cycle(session_results):
    """Full cycle of template generation and system optimization"""
    
    # 1. Generate templates from successful builds
    for system in session_results.successful_builds:
        generate_or_update_template(system)
    
    # 2. Analyze failures for improvement opportunities
    for failure in session_results.failures:
        analyze_failure_for_template_improvement(failure)
    
    # 3. Update system prompt based on learnings
    update_system_prompt_with_learnings()
    
    # 4. Optimize rule set based on performance
    optimize_rules_based_on_session()
    
    # 5. Generate improvement recommendations
    generate_next_session_optimizations()
```

This auto-template generation system ensures that every successful automation system becomes a reusable template that improves the entire system's capability over time.